{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CompTIA Linux+ (XK0-005)","text":"<p>Welcome to the documentation for the CompTIA Linux+ (XK0-005) certification. This documentation covers various topics related to Linux and system administration.</p>"},{"location":"01-understand-linux-fundamentals/","title":"Understanding Linux Fundamentals","text":""},{"location":"01-understand-linux-fundamentals/#fhs-basics","title":"FHS Basics","text":"<p>Definition and Purpose of FHS: The Filesystem Hierarchy Standard organizes the file system in a standardized hierarchical manner. It's not mandatory, but widely adopted as good practice in Linux systems. The FHS helps users understand where to find specific files and directories, aiding in effective system management.</p> <p>Comparison with Windows File System: The transcript contrasts the Linux FHS with the Windows file system. In Windows, the file system is directly tied to physical drives (like C: or D: drives). However, in Linux, the physical hardware is abstracted away. The user may access different directories like 'Downloads' or 'Documents' without knowing which physical disk they reside on. This abstraction provides a seamless experience, with the actual physical storage details being irrelevant to the user's navigation.</p> <p>Navigating Linux Filesystem: The concept of the 'root' of the filesystem is highlighted. The root (/) is different from the 'root directory' (/root). The root (/) is the base of the entire filesystem hierarchy. Understanding this is crucial for navigating Linux systems effectively.</p> <p>Command Example</p> <p>To display the current working directory:</p> <p><pre><code>pwd\n</code></pre> To display the contents of directories like <code>/boot</code>, <code>/etc</code>, or any other directory:</p> <pre><code>ls /etc\nls /boot\n</code></pre>"},{"location":"01-understand-linux-fundamentals/#system-files-and-directories","title":"System Files and Directories","text":"<p>The importance of understanding the specific roles and purposes of various directories in the FHS is emphasized. This knowledge is vital for tasks like mounting devices or identifying connected hardware.</p> <p>Various System Files and Directories</p> <p>Boot Directory (/boot): This directory contains essential files required for booting the system, such as the kernel image, bootloader files, initial RAM disk image, and kernel configuration files. It includes specific files like config (indicating the kernel version) and vmlinuz (the compressed Linux kernel executable).</p> <p>Etc Directory (/etc): This is where system configuration files are stored. The directory includes numerous .conf files and subdirectories for configuring different aspects of the system, such as network settings through netplan.</p> <p>Lib Directory (/lib): This directory houses crucial libraries needed for system operation. Examples include libraries for package management (apt), handling printers (cups), Python programming language support, and applications like rhythm box and libreoffice.</p> <p>Var Directory (/var): Home to variable data, which includes information that changes in size or content over time, like logs and emails. An example is the /var/log subdirectory, containing various logs, including kernel messages.</p>"},{"location":"01-understand-linux-fundamentals/#the-dev-directory","title":"The Dev Directory","text":"<p>The \"dev\" directory is an essential part of the Linux file system, containing device files that allow the system to communicate with hardware devices.</p> <p>The \"dev\" Directory: The \"dev\" directory houses device files that enable communication between the operating system and hardware devices like keyboards, USB drives, and more.</p> <p>Device File Naming Conventions: Device files in the \"dev\" directory follow a naming convention. For example, \"sda\" typically represents a hard drive, and \"a\" indicates it's the first hard drive. Additional drives are named \"sdb,\" \"sdc,\" and so on. If there are partitions, they are numbered, like \"sda1\" or \"sdb3,\" indicating the first partition of the first drive or the third partition of the second drive.</p> <p>\"tty\" Entries: The \"dev\" directory may contain \"tty\" entries, representing terminals or consoles. When you log in via a terminal, it will create a corresponding \"tty\" entry.</p> <p>Special Device Files: There are special device files in the \"dev\" directory. For example, \"/dev/null\" is used to discard information put into it. This can be helpful when dealing with commands that produce both valid output and error messages.</p> <p>\"/dev/random\": This special file is used to generate random data, which can be useful for applications that require random data, such as encryption or password generation.</p> <p>System Administration: Device files in the \"dev\" directory play a vital role in system administration, and understanding how to use them can be valuable for managing a Linux system effectively.</p>"},{"location":"01-understand-linux-fundamentals/#the-proc-directory-proc","title":"The Proc Directory - /proc","text":"<p>The /proc directory in Linux serves as a valuable resource for gaining insights into the system's current state, including processes, memory usage, and other system-related information.</p> <p>Virtual File System: The /proc directory is a virtual file system that exists in memory. It's dynamically created when the system boots up, and it holds various types of system-related information.</p> <p>Process Information: One of the primary purposes of the /proc directory is to provide information about running processes. Each running process has a corresponding directory within /proc, identified by its process ID (PID). These directories contain information about the process, including memory usage and associated files.</p> <p>Process ID (PID): The PID is a numerical value associated with each process and is used to identify and manage processes on the system. The /proc directory contains directories named after these PIDs, allowing easy access to process-related information.</p> <p>Command Example</p> <p>To view the running processes and their PIDs, use the following command:</p> <pre><code>ps -e\n</code></pre> <p>Dynamic Updates: The /proc directory is dynamically updated in real-time. When a process starts or stops, its corresponding directory is created or removed in /proc. This dynamic nature reflects the current state of processes on the system.</p> <p>Other Information: In addition to process-related data, the /proc directory provides access to various system information files. Examples include information about interrupts, supported file systems, memory usage, networking, and more. These files can be useful for troubleshooting and monitoring system performance.</p> <p>/proc/meminfo: The /proc/meminfo file contains information about system memory usage, including total memory, free memory, and caching/buffering statistics.</p> <p>Command Example</p> <p>To view the memory usage of the system, use the following command:</p> <pre><code>/proc$ cat meminfo\n</code></pre> <p>/proc/net: The /proc/net directory contains network-related information, such as routing tables and protocol-specific details.</p> <p>/proc/sys: The segment mentions that the next topic of discussion will be the /sys directory. This directory is also essential and used for various system configuration and control settings.</p>"},{"location":"01-understand-linux-fundamentals/#the-sys-directory","title":"The Sys Directory","text":"<p>This is another important virtual file system in Linux: the <code>/sys</code> file system.</p> <p>Understanding the Sys File System</p> <p>The <code>/sys</code> file system, also known as <code>sysfs</code>, provides a wealth of information about kernel modules, hardware, and driver information. It's crucial to note that <code>sysfs</code> is mounted and accessible from the <code>/sys</code> directory.</p> <p>Key Features of the Sys File System</p> <ul> <li>Real-Time Updates: Just like the <code>/proc</code> file system, <code>/sys</code> is updated on the fly in real time.</li> <li>Kernel and Hardware Information: Contains data related to kernel modules and hardware devices.</li> <li>Accessible Information: Offers insight into various system components.</li> </ul> <p>Navigating the Sys Directory</p> <p>Command Example</p> <p>Take a look at navigating the <code>/sys</code> directory:</p> <p><pre><code>cd /sys\nls\n</code></pre> This will display the hrives on the system (examples = sda, sdb):</p> <pre><code>cd block/\nls\n</code></pre>"},{"location":"01-understand-linux-fundamentals/#fhs-user-files-and-directories","title":"FHS User Files and Directories","text":"<p>Directories and files relating to users in the Filesystem Hierarchy Standard (FHS). Exploring directories like the home directory, media directory, mount directory, root directory, and the TMP directory.</p> <p>The Home Directory</p> <p>The home directory is a personal space for users. Each user has a directory named after their username where personal files like documents, pictures, and videos are stored. It's represented by a tilde (<code>~</code>) in the command prompt.</p> <p>Exploring the Home Directory</p> <p>Command Example</p> <p>Navigating the <code>/home</code> directory:</p> <pre><code>cd ~\nls\n</code></pre> <p>The Media Directory</p> <p>The media directory is used for mounting and accessing removable media such as DVDs or USB drives. It's typically empty unless a removable media is connected.</p> <p>Accessing the Media Directory</p> <p>Command Example</p> <p>Navigating the <code>/media</code> directory:</p> <pre><code>cd /media\nls\n</code></pre> <p>The Mount Directory</p> <p>Similar to the media directory, the mount directory is used for temporary mounting of file systems, especially those mounted over the network or external drives used as file systems.</p> <p>Using the Mount Directory</p> <p>Command Example</p> <p>Navigating the <code>/mnt</code> directory:</p> <pre><code>cd /mnt\nls\n</code></pre> <p>The Root Directory</p> <p>The root directory (<code>/root</code>) is the home directory for the root user, similar to the regular user's home directory. It's accessible only by the root user.</p> <p>Accessing the Root Directory as Root User</p> <p>Command Example</p> <p>To access the Root Directory as the root user, you can use the following commands in your terminal:</p> <pre><code>sudo -i\ncd /root\n</code></pre> <p>The TMP Directory</p> <p>The TMP directory is used for temporary files. It has relaxed permissions, allowing the execution of files, which can be a security concern. Files in this directory are often cleared upon system reboot.</p> <p>Viewing the TMP Directory</p> <p>Command Example</p> <p>To view the contents of the TMP Directory, you can use the following command in your terminal:</p> <pre><code>ls /tmp\n</code></pre>"},{"location":"01-understand-linux-fundamentals/#fhs-system-binaries-and-programs","title":"FHS System Binaries and Programs","text":"<p>Focus on system binaries and programs within the File System Hierarchy Standard (FHS). Explore several key directories, including the <code>bin</code> directory, the <code>opt</code> directory, the <code>sbin</code> directory, and user directories.</p> <p>The <code>bin</code> Directory</p> <p>Command Example</p> <p>The <code>bin</code> directory. You can find it at the root level:</p> <pre><code>cd /\nls\ncd bin\nls\n</code></pre> <p>Inside the bin directory, you'll find essential binary executables needed for the system to operate. These executables are responsible for various system functions and are often denoted by their green text color, indicating that they are executable files.</p> <p>The <code>opt</code> Directory</p> <p>Command Example</p> <p>The <code>opt</code> directory. You can find it at the root level:</p> <pre><code>cd /\nls\ncd opt\nls\n</code></pre> <p>The opt directory is typically empty initially. It serves as a location for optional software packages that are not required for the system but can be installed from third-party sources. This separation allows for easy removal of these programs and isolates them from the rest of the system.</p> <p>The <code>sbin</code> Directory</p> <p>Command Example</p> <p>The <code>sbin</code> directory. You can find it at the root level:</p> <pre><code>cd /\nls\ncd sbin\nls\n</code></pre> <p>The sbin directory contains system-level binary executables required for system operation. These executables often require administrator privileges (root access) to run. They are crucial for system maintenance and control.</p> <p>The User Directory</p> <p>Command Example</p> <p>The <code>user/bin</code> directory. You can find it at the root level:</p> <pre><code>cd /user\nls\ncd bin\nls\n</code></pre> <p>Within the <code>user</code> directory, you'll find various subdirectories containing executables, libraries, and documentation. Of particular interest is the <code>user/bin</code> directory, which is used for local user programs.</p> <p>The <code>user/bin</code> directory holds executables for local user programs. These programs are accessible to individual users and can be run without administrative privileges. You can use these executables in your user account without specifying their full paths, thanks to the PATH environment variable, which includes the directory location.</p>"},{"location":"02-understand-linux-boot-process-and-hardware/","title":"Understand Linux Boot Process and Hardware","text":""},{"location":"02-understand-linux-boot-process-and-hardware/#understand-linux-boot-process-and-hardware","title":"understand Linux boot process and hardware","text":"<p>The focus on the Linux boot process. Emphasis on the Linux kernel and associated hardware. BIOS and UEFI Explanation of the BIOS (Basic Input/Output System) as firmware. Introduction to UEFI (Unified Extensible Firmware Interface) as a modern replacement for BIOS.</p> <p>Identifying PCI Devices Explanation of identifying PCI (Peripheral Component Interconnect) devices. Noting that PCI is a legacy technology, unlike USB.</p>"},{"location":"02-understand-linux-boot-process-and-hardware/#partition-tables-and-firmware","title":"Partition Tables and Firmware","text":"<p>Differences Between MBR and GPT</p> <p>The differences between MBR (Master Boot Record) and GPT (GUID Partition Table) in the context of disk partitioning.</p> <p>When you have a disk and you want to store data on it, you can't just put data on it without any preparation. Instead, the disk needs to be formatted.</p> <p>But before formatting, it needs something called a partition table. </p>"},{"location":"02-understand-linux-boot-process-and-hardware/#partition-table-styles","title":"Partition Table Styles","text":"<p>Partition Tables Two different partition tables, specifically MBR (Master Boot Record) and GPT (GUID Partition Table). There are two main styles of partition tables: MBR and GPT. These two styles are quite different.</p> <p>MBR (Master Boot Record)</p> <p>MBR is the older of the two and has been widely used. Its biggest advantage is its compatibility with various systems and boot processes. However, it has limitations compared to GPT.</p> <p>GPT (GUID Partition Table)</p> <p>GPT is more modern and advanced. It offers more features and flexibility compared to MBR. GPT is suitable for larger disks, supports a higher number of partitions, and provides better support for UEFI booting and data integrity.</p> <p>Choosing Between MBR and GPT</p> <p>The choice between MBR and GPT depends on your specific needs and hardware. If you have a legacy system or require maximum compatibility, MBR might be the better choice. However, if you have a modern system with larger disks and need advanced features, GPT is usually the preferred option. Your decision should be based on your specific requirements.</p>"},{"location":"02-understand-linux-boot-process-and-hardware/#external-hardware","title":"External Hardware","text":"<p>Peripherals Focus on working with peripherals, particularly USB devices. Mention of commands to identify connected USB devices. - External Hardware in Linux:   - Mnaging external hardware components in Linux.</p> <ul> <li> <p>USB devices are common external hardware used for storing data and possibly even as a boot source.</p> </li> <li> <p>PCI Devices Older Peripheral Component Interconnect (PCI) interface used to connect devices like SCSI, modems, and network cards.</p> </li> <li> <p>Importance of Hardware Management: Understanding and managing external hardware components is crucial, especially for Linux+ examination.</p> </li> <li> <p><code>lspci</code> Command: Lists PCI buses and devices connected to them.</p> </li> <li> <p>Using man Command: Using the <code>man</code> command to access manual pages for Linux utilities.</p> </li> <li> <p>Options for <code>lspci</code>: The use of various options like <code>-v</code>, <code>-vv</code>, <code>-vvv</code>, <code>-b</code>, <code>-k</code>, and <code>-D</code> with <code>lspci</code> for detailed information.</p> </li> <li> <p><code>lsusb</code> Command: The <code>lsusb</code> command for listing USB devices in Linux.</p> </li> <li> <p>Accessing lsusb Manual Pages: How to access manual pages for the <code>lsusb</code> command using <code>man</code>.</p> </li> <li> <p>Using <code>lsusb</code>: The use of <code>lsusb</code> to list connected USB devices and obtain verbose information with <code>-v</code>.</p> </li> <li> <p>dmidecode Command: The <code>dmidecode</code> command for inspecting hardware information, including BIOS, motherboard, processor, and memory details.</p> </li> <li> <p>Accessing dmidecode Manual Pages: How to access manual pages for the <code>dmidecode</code> command using <code>man</code>.</p> </li> <li> <p>Using dmidecode: The use of <code>dmidecode</code> with <code>-t</code> to inspect various hardware details, requiring superuser privileges with <code>sudo</code>.</p> </li> </ul>"},{"location":"02-understand-linux-boot-process-and-hardware/#understanding-the-boot-process","title":"Understanding the Boot Process","text":"<p>Linux Boot Process Overview High-level overview of the Linux boot process. Mention of components like BIOS/UEFI and the bootloader Grub2. - BIOS/UEFI: The boot process starts with the BIOS (or UEFI) firmware, which initiates the boot sequence. BIOS and UEFI are often used interchangeably, even though modern systems usually use UEFI.</p> <ul> <li> <p>POST (Power-On Self Test): After the BIOS/UEFI is invoked, the system performs a POST, which is a set of hardware self-tests to ensure everything is functioning correctly.</p> </li> <li> <p>Bootloader: The bootloader, such as GRUB2 (the most common one), is loaded by BIOS/UEFI. The bootloader's job is to load the Linux kernel.</p> </li> <li> <p>Kernel (vmlinuz): The Linux kernel (vmlinuz) is a compressed image that is hardware-agnostic and generic. It forms the core of the operating system.</p> </li> <li> <p>initrd (Initial RAM Disk): The initrd is a RAM disk loaded in memory. It contains kernel modules necessary to identify hardware and allow the full kernel to be loaded.</p> </li> <li> <p>Kernel Modules: Initrd loads necessary kernel modules, enabling the kernel to mount the hard drive and access other modules stored on it.</p> </li> <li> <p>System Initialization: Once the kernel is fully loaded, control is handed over to the system initialization process, which varies (e.g., SysVinit, Upstart, or systemd). In modern systems, systemd is often used to manage system services and initialize the system.</p> </li> <li> <p>Operational System: After system initialization, the Linux system becomes fully operational, and users can log in, run services, and perform regular tasks.</p> </li> </ul>"},{"location":"02-understand-linux-boot-process-and-hardware/#the-bootloader","title":"The Bootloader","text":"<p>Grub2 A closer look at the Grub2 bootloader and its role in the boot process.</p> <ul> <li> <p>Bootloader Evolution: The evolution of Linux bootloaders, starting with LILO, followed by GRUB (GRUB Legacy), and finally, GRUB2 (often referred to as just GRUB in casual terms).</p> </li> <li> <p>GRUB2 Features: GRUB2 is a significant improvement over its predecessors as it can handle UEFI firmware and GPT partition style, making it more compatible with modern systems.</p> </li> <li> <p>GRUB Configuration File: The configuration file for GRUB2 is typically located in <code>/etc/default/grub</code> on Debian-based systems and <code>/boot/grub2/grub.cfg</code> on Red Hat-based systems (like Rocky Linux).</p> </li> <li> <p>Modifying Configuration: Users should not modify <code>grub.cfg</code> directly but should instead make changes in <code>/etc/default/grub</code>. After making changes, the <code>update-grub</code> command (on Debian-based systems) or <code>grub2-mkconfig</code> (on Red Hat-based systems) is used to apply the modifications to <code>grub.cfg</code>. One big distinction about GRUB2, now, we could handle UEFI firmware, which means we could handle the GPT partition style.</p> </li> </ul> <p>Warning Message</p> <p>This is where the grub.cfg file is located.</p> <p>root location of grub2 configuration file</p> <p>You're not meant to modify this configuration file directly.</p> <pre><code>root@systemn: cd /boot/grub ls\n</code></pre> <p>Location of grub2 configuration file for modification indirectly</p> <p>This is the location to modify the configuration file indirectly.</p> <pre><code>root@systemn: cd /etc\nroot@systemn:/etc$ cd default\nroot@systemn:/etc/default$ cat grub\n</code></pre> <p>To update changes run command below</p> <p>if you change this file, run 'update-grub' afterwards to update.</p> <pre><code>root@systemn:/etc/default$ update-grub\n</code></pre> <ul> <li> <p>Distribution Differences: Red Hat-based systems explicitly use the directory name <code>GRUB2</code>, while Debian-based systems often refer to GRUB2 as just GRUB. The command for generating the configuration file also differs between distributions.</p> </li> <li> <p>Understanding Differences: It's important to understand these distribution-specific differences and commands when working with Linux bootloaders.</p> </li> </ul>"},{"location":"02-understand-linux-boot-process-and-hardware/#boot-sources","title":"Boot Sources","text":"<p>Different Boot Sources Explanation of various boot sources beyond just hard drives. The ability to boot kernel images from a network. - Bootloader Evolution: The text discusses the historical evolution of Linux bootloaders, starting with LILO and its limitations with MBR-based systems.</p> <ul> <li> <p>GRUB Legacy: The original GRUB, referred to as \"GRUB Legacy,\" allowed users to choose the operating system during boot through a menu. Its configuration was stored in <code>/boot/grub/menu.lst</code>.</p> </li> <li> <p>Transition to GRUB2: GRUB Legacy was replaced by GRUB2, a completely rewritten and more versatile bootloader. It's often referred to as just \"GRUB\" in casual terms.</p> </li> <li> <p>GRUB2 Features: GRUB2 has the capability to handle UEFI firmware and GPT partition style, making it suitable for modern systems.</p> </li> <li> <p>GRUB Configuration File: The configuration file for GRUB2 is typically located in <code>/etc/default/grub</code> on Debian-based systems and  <code>/boot/grub2/grub.cfg</code> on Red Hat-based systems (e.g., Rocky Linux).</p> </li> <li> <p>Modifying Configuration: Users should make changes to <code>/etc/default/grub</code> rather than directly modifying grub.cfg. The changes are applied using the <code>update-grub</code> command on Debian-based systems or grub2-mkconfig on Red Hat-based systems.</p> </li> <li> <p>Distribution Differences: Red Hat-based systems explicitly use the directory name GRUB2, while Debian-based systems often refer to GRUB2 as just \"GRUB.\" The command for generating the configuration file differs between distributions.</p> </li> <li> <p>Understanding Differences: It's important to be aware of these distribution-specific differences and commands when working with Linux bootloaders.</p> </li> <li> <p>Boot Sources in Linux: The text discusses various boot sources in Linux, including PXE (preboot execution environment), network booting, CD/DVD, USB drives, and live operating systems for forensics and analysis.</p> </li> </ul>"},{"location":"02-understand-linux-boot-process-and-hardware/#kernel-panic","title":"Kernel Panic","text":"<p>Kernel Panic Introduction to kernel panic, what it is, and how to identify its potential causes. Real-world applications of solving kernel panics using backups.</p> <ul> <li> <p>Kernel Panic: Kernel panic occurs when the Linux kernel stops running in memory, causing the entire system to crash.</p> </li> <li> <p>Causes of Kernel Panic: Kernel panic can happen due to various reasons, including driver issues, hardware problems (e.g., memory or CPU issues), malware infections, or problems during a kernel update.</p> </li> <li> <p>Backup Kernel: It's essential to have a working backup of the kernel before performing updates to allow for a rollback in case of issues.</p> </li> <li> <p>Diagnosing Kernel Panic: To diagnose kernel panic issues, check log files such as kern.log, syslog, and dmesg for kernel-related messages, although detailed diagnosis often requires kernel expertise.</p> </li> <li> <p>Utilizing Alternative Kernel Images: Linux systems often keep backup kernel images, allowing users to boot from a previous working configuration in case of kernel issues. Access to these images is typically available through the GRUB menu during system boot.</p> </li> <li> <p>GRUB Menu: The GRUB menu allows users to choose different kernel images during system boot, providing a way to recover from kernel panic situations.</p> </li> <li> <p>Troubleshooting: Understanding how to access the GRUB menu and selecting alternative kernel images is a practical solution to recover from kernel panic issues.</p> </li> </ul> <p>Log files location</p> <p>These are some location you could findthe reasons for the error!.</p> <pre><code>root@systemn: cd /var\nroot@systemn:/var$ ls\nroot@systemn:/var$ cd log\nroot@systemn:/var/log$ ls\nroot@systemn:/var/log$ cat kern.log\nroot@systemn:/var/log$ clear\nroot@systemn:/var/log$ cat syslog\nroot@systemn:/var/log$ clear\nroot@systemn:/var/log$ cat dmesg\n</code></pre> <p>This is where you will find old kernal images to rolback too.</p> <pre><code>root@systemn: cd /boot\nroot@systemn:/boot$ ls\n</code></pre> <p>Tip</p> <p>To restart the system manually. <pre><code>root@systemn: shutdown -r now\n</code></pre> Hold down the shift button, what happens is you will be presented with the grub menu and you can choose different images such as a resuce image.</p>"},{"location":"03-understand-package-compilation-and-storage-concepts/","title":"Understand Package Compilation and Storage Concepts","text":""},{"location":"03-understand-package-compilation-and-storage-concepts/#understanding-source-code","title":"Understanding Source Code","text":"<p>Understanding Source Code: The fundamental concept of source code in software development. It distinguishes between open-source and closed-source software, providing an understanding of how software programs are created and modified from their source code.</p> <ul> <li> <p>Source code is the code that makes up a computer program and is typically not visible or relevant to end users.</p> </li> <li> <p>There are two main approaches to software development: closed source (proprietary) and open source. Closed source code is not publicly available, while open source code is publicly accessible, modifiable, and shareable.</p> </li> <li> <p>Linux has a strong favor for open source software development, making source code accessible to the community.</p> </li> <li> <p>Compiling source code is the process of transforming it into an executable binary that can be run as a program.</p> </li> <li> <p>In Linux, the process of compiling source code involves installing a compiler (GCC), downloading the source code, handling dependencies, configuring, and running a make script to automate compilation.</p> </li> <li> <p>Makefiles are used to automate compilation tasks and simplify the process.</p> </li> </ul>"},{"location":"03-understand-package-compilation-and-storage-concepts/#compiling-from-source-on-ubuntu","title":"Compiling from Source on Ubuntu","text":"<p>Compiling from Source on Ubuntu: The process of compiling software programs directly from their source code on Ubuntu Linux. It outlines the steps and considerations required for compiling programs on this distribution.</p> <ul> <li> <p>Source code compilation on Linux allows users to download and build software from its source code, providing flexibility and customization options.</p> </li> <li> <p>Linux distributions often use package managers (e.g., APT for Ubuntu, DNF for Red Hat) to simplify software installation. However, compiling from source can be advantageous for specific needs.</p> </li> <li> <p>Building software from source requires essential development tools, including the GCC compiler, which can be installed using package managers.</p> </li> <li> <p>To demonstrate source code compilation, the \"ncdu\" utility is downloaded, extracted, and built from source. Dependencies are checked using the \"configure\" script.</p> </li> </ul> <p>Command to install the build-essential package on Ubuntu</p> <p>To get access to the GCC compiler, amongst a whole bunch of other development tools and libraries.:</p> <p><pre><code>sudo apt install build-essential\n</code></pre> Install wget to install and download things from the internet.:</p> <pre><code>sudo apt install wget\nwget URL from internet example (https://dev.yorhel.nl/download/ncdu-1.19.tar.gz)\ntar -xzf ncdu-1.19.tar.gz\nls\ncd ncdu-1.19.tar.gz\n</code></pre> <ul> <li> <p>The \"Makefile\" is a script used to automate the compilation process, simplifying it for users.</p> </li> <li> <p>Compiling from source includes running \"make\" and, for system-wide installation, \"sudo make install.\"</p> </li> </ul> <p>Command to install the build-essential package on Ubuntu</p> <p>Install wget to install and download things from the internet.:</p> <pre><code>sudo apt-get install libncurses5-dev\n</code></pre> <ul> <li> <p>Adding the binary's directory to the system's PATH makes the compiled program accessible without specifying the full path.</p> </li> <li> <p>The process may vary depending on the software, but downloading, extracting, configuring, making, and installing are common steps.</p> </li> <li> <p>Different Linux distributions may have their own package managers and package formats, but the source code compilation process remains relatively consistent.</p> </li> </ul>"},{"location":"03-understand-package-compilation-and-storage-concepts/#compiling-from-source-on-rocky-linux","title":"Compiling from Source on Rocky Linux","text":"<p>Compiling from Source on Rocky Linux: Focus on compiling programs from source code, but specifically on the Rocky Linux distribution. While the process shares similarities with Ubuntu, there are key differences that are explained in this section.</p>"},{"location":"03-understand-package-compilation-and-storage-concepts/#raid-including-raid-0-raid-1-and-raid-5","title":"RAID (including RAID 0, RAID 1, and RAID 5)","text":"<p>RAID (Redundant Array of Independent Disks): The concept of RAID and its importance in data storage and redundancy. It provides explanations for different RAID levels, including RAID 0, RAID 1, and RAID 5, highlighting their distinct features and use cases.</p> <ul> <li> <p>Introduction to Storage Redundancy       Explaining the concept of redundancy in storage to avoid single points of failure. Options like copying to USB or cloud instances for backup.</p> <ul> <li> <p>What is RAID?   RAID stands for Redundant Array of Independent (or Inexpensive) Disks. It's a method for storing the same data in different places on multiple hard disks.</p> </li> <li> <p>Types of RAID   Discussion on two forms of RAID - hardware RAID and software RAID, with a focus on the latter as implemented by the Linux kernel.</p> </li> <li> <p>RAID 0 - Striping   RAID 0 offers zero fault tolerance (striping). It improves performance but provides no redundancy, as data is split across multiple disks.</p> </li> <li> <p>RAID 1 - Mirroring   RAID 1 provides fault tolerance by mirroring data. It offers improved read performance but not write performance and reduces total storage capacity by half.</p> </li> <li> <p>RAID 5 - Striping with Parity   RAID 5 requires a minimum of three disks and uses striping with a parity bit for redundancy. It allows data reconstruction if one disk fails.</p> </li> <li> <p>RAID Levels Summary   Summary of RAID levels for the Linux+ exam. RAID 0 (striping, no fault tolerance), RAID 1 (mirroring, fault tolerance), and RAID 5 (striping with parity, fault tolerance with minimum three disks).</p> </li> </ul> </li> </ul>"},{"location":"03-understand-package-compilation-and-storage-concepts/#storage-types-including-file-block-and-object-storage","title":"Storage Types (including file, block, and object storage)","text":"<p>Storage Types: The various types of storage systems used in computing, including file storage, block storage, and object storage. It elucidates the characteristics of each storage type and when to choose one over the other based on specific requirements.</p> <ul> <li> <p>Introduction to Storage Types in Linux     Overview of three different styles of storage available in Linux - file storage, block storage, and object storage.</p> <ul> <li> <p>File Storage   In file storage, data is stored within individual files like text or .doc files. It's the common way of saving documents on a drive, and it benefits from a hierarchical file system for easier management.</p> </li> <li> <p>Block Storage   Block storage involves chunking data into blocks, each with a unique identifier, leading to better performance. Common block storage devices include hard drives, SSDs, SANs, and cloud solutions.</p> </li> <li> <p>Object Storage   Object storage stores data as unique objects with universal IDs, commonly used in cloud environments. It's rich in metadata, making data search and queries easier, but is slower in processing compared to block storage.</p> </li> <li> <p>Choosing the Right Storage Type   The best storage type depends on the context. File storage suits regular users with small data needs, block storage is ideal for performance-intensive tasks, and object storage is well-suited for cloud environments.</p> </li> </ul> </li> </ul>"},{"location":"03-understand-package-compilation-and-storage-concepts/#fuse-filesystem-in-userspace","title":"FUSE (Filesystem in Userspace)","text":"<p>FUSE (Filesystem in Userspace): Introducing the concept of FUSE, which stands for Filesystem in Userspace. It explains how FUSE enables users to mount filesystems without requiring superuser privileges and offers insights into its practical applications in Linux.</p> <ul> <li> <p>Introduction to FUSE     Explanation of how Filesystem in Userspace (FUSE) allows regular users to mount filesystems without needing superuser privileges, covering objective 1.1 in the examination.</p> <ul> <li> <p>Traditional Mounting vs. FUSE   Traditionally, mounting filesystems requires superuser privileges. FUSE enables this for regular users, emphasizing user accessibility.</p> </li> <li> <p>Demonstration Setup   Setting up a scenario using a Rocky Linux machine on Linode for a practical demonstration of FUSE.</p> </li> <li> <p>Creating and Using FUSE   Steps to create a directory and a text file on a remote server, and then mount this directory locally using SSHFS, a form of FUSE.</p> </li> <li> <p>Installing and Using SSHFS   Instruction on installing SSHFS and using it to mount a remote directory to a local system, demonstrating FUSE's capability.</p> </li> <li> <p>Practical Demonstration of FUSE   Showcasing how to mount a remote file system using SSHFS and accessing its contents on the local machine without superuser privileges.</p> </li> <li> <p>Implications of FUSE   Highlighting that FUSE allows regular users to mount filesystems, overcoming traditional limitations, with SSHFS being one example of its application.</p> </li> <li> <p>Conclusion on FUSE   Summarizing the capabilities of FUSE and its importance for regular users in mounting filesystems without administrative rights.</p> </li> </ul> </li> </ul> <p>install sshfs</p> <p>How To Use SSHFS to Mount Remote File Systems Over SSH. Example only:</p> <pre><code>sudo apt install sshfs\nsudo mkdir /mnt/droplet\nsudo sshfs root@10.0.0.23:other_server /mnt/droplet\n</code></pre>"},{"location":"04-edit-files-on-linux-systems/","title":"Edit Files on Linux Systems","text":""},{"location":"04-edit-files-on-linux-systems/#sed","title":"Sed","text":"<p>Introduction to sed Command Introduction to the stream editor (sed) in Linux, with a focus on its capabilities and usage in the upcoming section.</p> <p>Sed Utility in Linux The <code>sed</code> utility in Linux, which stands for \"stream editor\".</p> <p>Sed Basics - <code>sed</code> can delete lines, substitute text, append text, or extract text from text files. - By default, <code>sed</code> prints the entire file as a stream, but you can modify this behavior using switches. - Use <code>-n</code> to suppress automatic printing of the entire file and selectively print lines. - Use <code>sed '1d' filename</code> to delete the first line in a file. - With <code>-i</code>, you can edit the file directly instead of just printing output. - To substitute text globally, add <code>g</code> at the end of the substitution command (e.g., <code>sed 's/Scotland/UK/g' filename</code>). - Explore more features and options using <code>man sed</code> for detailed information.</p>"},{"location":"04-edit-files-on-linux-systems/#awk","title":"Awk","text":""},{"location":"04-edit-files-on-linux-systems/#printf","title":"Printf","text":""},{"location":"04-edit-files-on-linux-systems/#nano","title":"Nano","text":"<p>Nano Text Editor Nano is described as a simple and user-friendly text editor, suitable for those unfamiliar with Linux due to its ease of use.</p>"},{"location":"04-edit-files-on-linux-systems/#understanding-vim","title":"Understanding Vim","text":"<p>VIM Text Editor: A powerful and complex text editor, different from regular text editors, with emphasis on its significance for Linux engineers and Linux+ certification candidates.</p>"},{"location":"04-edit-files-on-linux-systems/#editing-files-with-vim","title":"Editing Files with Vim","text":""}]}